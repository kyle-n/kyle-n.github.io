import { c as create_ssr_component } from "./ssr.js";
const metadata = {
  "layout": "post",
  "title": "Avoiding common pitfalls in RxJS",
  "date": "2022-10-12T00:00:00.000Z",
  "keywords": "javascript, typescript, rxjs",
  "image": "rxjs-logo.png",
  "caption": "Via rxjs.dev"
};
const Rxjs_land_of_paradoxes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<p data-svelte-h="svelte-j7xrag">As an <a href="https://www.bitovi.com/frontend-javascript-consulting/angular-consulting" rel="nofollow">Angular consultant</a>, I see people struggle with RxJS a lot. Which is understandable. Observables are a powerful tool for working with data streams, but they have quirks that can trip up developers new to the library.</p> <p data-svelte-h="svelte-1jxr2lk">In this blog post, we’ll explore how to avoid three common pitfalls when using RxJS in your own projects.</p> <h3 data-svelte-h="svelte-1ta4gly">Quick, what’s an Observable?</h3> <p data-svelte-h="svelte-4vwgdn">An <a href="https://rxjs.dev/guide/observable" rel="nofollow">Observable</a> is a stream of values delivered over time. It’s similar to a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow">Promise</a>. A Promise represents an asynchronous operation that completes or fails <em>once</em>, for all subscribers.</p> <p data-svelte-h="svelte-omnvsg">RxJS is mind-bending because, depending on the Observable, it may be synchronous or asynchronous, deliver one value or multiple, and share that value with one or multiple subscribers.</p> <h3 data-svelte-h="svelte-1gktoqr">Paradox 1: Observables are asynchronous, unless they are synchronous</h3> <p data-svelte-h="svelte-bo8l7c">Most Observables people deal with, especially in Angular, are asynchronous.</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>apiService<span class="token punctuation">.</span><span class="token function">getSomeApiDataById</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>data <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-5nk9a3">This is probably why many believe <em>all</em> Observables are asynchronous. However, consider the Observable <code>sequence$</code> in the following code:</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> from <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> sequence$ <span class="token operator">=</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before'</span><span class="token punctuation">)</span>
sequence$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1bz4d2w">If you run this code, you will see:</p> <pre class="language-undefined"><!-- HTML_TAG_START -->${`<code class="language-undefined">before
1
2
3
after</code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-19awyf"><code>sequence$</code> will emit its values <em>synchronously</em> and complete before we get to the last line and log <code>after</code>.</p> <p data-svelte-h="svelte-1qgn85x">It helps to know Observables can be synchronous when mocking them in unit tests. People substitute a network request with <code>of(someTestData)</code> and end up testing an imaginary version of their component where API calls run synchronously.</p> <h3 data-svelte-h="svelte-g413ws">Paradox 2: Observables do not run until subscribed to, unless they do</h3> <p data-svelte-h="svelte-1arm9yk">A fun thing about Observables is they work completely differently if they are <a href="https://benlesh.medium.com/hot-vs-cold-observables-f8094ed53339" rel="nofollow">hot or cold</a>.</p> <p data-svelte-h="svelte-tstr5x">Let’s go back to our friend from the previous example, <code>sequence$</code>. This time, he’ll log when emitting.</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> from <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> sequence$ <span class="token operator">=</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
  <span class="token function">tap</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'emitting'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before'</span><span class="token punctuation">)</span>
sequence$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-l6kwm">Run that and you’ll see:</p> <pre class="language-undefined"><!-- HTML_TAG_START -->${`<code class="language-undefined">before
emitting 1
1
emitting 2
2
emitting 3
3
done emitting
after</code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1kr59l"><code>sequence$</code> is a <strong>cold</strong> Observable. It won’t run until we subscribe to it. That’s why <code>before</code> is logged before <code>emitting 1</code>.</p> <p data-svelte-h="svelte-b7wfcn">A <strong>hot</strong> Observable runs regardless of whether anything in your code is subscribed to it and listening for events.</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> fromEvent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inputElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'inputElement'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HtmlInputElement<span class="token punctuation">;</span>
<span class="token keyword">const</span> userInput$ <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>inputElement<span class="token punctuation">,</span> <span class="token string">'change'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userInput$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1mvxbt2">In this case, we can subscribe or not subscribe to <code>userInput$</code>. Subscribing will not cause more or fewer values to be emitted. <code>userInput$</code> is a stream of values representing whatever the user writes in a text field. The user could be typing regardless of whether we’ve subscribed to their inputs.</p> <h3 data-svelte-h="svelte-1jww87a">Paradox 3: Observables complete automatically, unless they don’t</h3> <p data-svelte-h="svelte-v3hy9j">When an Observable is running, it can do one of three things:</p> <ol data-svelte-h="svelte-1anylmp"><li>Emit a value</li> <li>Error, and never emit more values</li> <li>Complete, and never emit more values</li></ol> <p data-svelte-h="svelte-bnf07b">If it errors, it cannot complete, and vice versa.</p> <p data-svelte-h="svelte-1odg8jv">It’s important to think about completing Observables, because you don’t want unneeded subscriptions hogging memory or causing unwanted behavior.</p> <p data-svelte-h="svelte-1jmqs00">However, many developers don’t realize some Observables complete themselves. Consider <code>sequence$</code>:</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> from <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> sequence$ <span class="token operator">=</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sequence$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-uv08qx"><code>sequence$</code> is the Observable representation of the array <code>[1, 2, 3]</code>. It converts that array into a stream and emits its values. Once it’s emitted every value in the array, it completes itself. Which makes sense! It’s emitted all the values.</p> <p data-svelte-h="svelte-1ttghvq">That means for a lot of Observables, you don’t actually have to worry about cleaning up their subscriptions. You can avoid a common mistake:</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>apiService<span class="token punctuation">.</span><span class="token function">doSomeNetworkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-17fn4wk"><code>doSomeNetworkRequest()</code> returns an Observable that completes itself. You don’t need a <code>take(1)</code>. Test it yourself by giving the Observable a callback that runs on completion:</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>apiService<span class="token punctuation">.</span><span class="token function">doSomeNetworkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>
    val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span>
    error <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'observable completed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-17u4be">Run a real version of this pseudocode and you’ll see the response logged, then <code>observable completed</code>.</p> <p data-svelte-h="svelte-167dadh">Again, this tracks when you think about what the Observable is modeling. It represents an HTTP request. That request will either complete and return a value, hang, or fail with an error. If the request succeeds, the Observable will emit one value, the response, and complete. It’s not a web socket. There’s no more data coming. Completing itself makes sense.</p> <p data-svelte-h="svelte-1vf47r0">Now look at our hot Observable again.</p> <pre class="language-typescript"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> fromEvent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inputElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'inputElement'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HtmlInputElement<span class="token punctuation">;</span>
<span class="token keyword">const</span> userInput$ <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>inputElement<span class="token punctuation">,</span> <span class="token string">'change'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userInput$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-w9hotu"><code>userInput$</code> will never complete by itself. Which makes sense. It represents the user’s text input. We don’t know when the user is done typing. That might be a while until they hit submit or just close the browser.</p> <p data-svelte-h="svelte-atiiat">When working with Observables, ask <em>what thing an Observable models</em>. If it makes sense that thing would complete automatically, its representing Observable probably does.</p> <h3 data-svelte-h="svelte-d7kqkf">Conclusion</h3> <p data-svelte-h="svelte-m4w991">Observables’ quirks may be challenging to learn, but the benefits make the effort worthwhile. Reactive programming makes complex async logic easier to read, write and debug.</p>`;
});
export {
  Rxjs_land_of_paradoxes as default,
  metadata
};
